<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on shishuoCh&#39;s Blog</title>
    <link>https://shishuochen.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on shishuoCh&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Sep 2023 11:37:01 +0800</lastBuildDate><atom:link href="https://shishuochen.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>题单收藏夹</title>
      <link>https://shishuochen.github.io/2023/vv6sqn_gt/</link>
      <pubDate>Fri, 08 Sep 2023 11:37:01 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/vv6sqn_gt/</guid>
      <description>✍ 写在前面 题单收藏自各个大佬，仅用作学习，侵删；所有参考的都有出处。 🎗 二分题单 二分答案系列 $\cdots$ end $\cdots$</description>
    </item>
    
    <item>
      <title>LC-2771. 构造最长非递减子数组（记忆化dfs的自我解惑）</title>
      <link>https://shishuochen.github.io/2023/a51ag9mj/</link>
      <pubDate>Mon, 10 Jul 2023 21:30:55 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/a51ag9mj/</guid>
      <description>写在前面 感觉这道题很适合记录一下，打破了我对 $dfs$ 的思维范式~ 2771. 构造最长非递减子数组 想不通的点 递归的传参怎样设置？ 递归的 $base$ $case$ 怎么写？ 如何进入下一</description>
    </item>
    
    <item>
      <title>LFU（Least Frequency Used）算法数据结构总结</title>
      <link>https://shishuochen.github.io/2023/q41afejy9/</link>
      <pubDate>Sat, 24 Jun 2023 22:21:54 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/q41afejy9/</guid>
      <description>写在前面 LFU（Least Frequency Used）算法也是一种缓存淘汰策略，顾名思义就是淘汰掉使用频次最少的数据，如果多个最低频次使用的就删除最久远的呢</description>
    </item>
    
    <item>
      <title>LRU（Least Recently Used）算法</title>
      <link>https://shishuochen.github.io/2023/qnwpygokg/</link>
      <pubDate>Sat, 24 Jun 2023 15:47:57 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/qnwpygokg/</guid>
      <description>写在前面 LRU (Least Recently Used) 算法就是一种缓存淘汰策略, 见名知意就是删除掉最久未使用的内存。题目要求get和put在$O(1)$时间内完成，哈希表可以做到</description>
    </item>
    
    <item>
      <title>Dijkstra 算法：最小路径或者最大路径</title>
      <link>https://shishuochen.github.io/2023/klkfgguu9/</link>
      <pubDate>Thu, 22 Jun 2023 20:24:56 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/klkfgguu9/</guid>
      <description>写在前面 Dijkstra 算法实质上就是 BFS 算法的加强版，算法的模拟过程就是BFS，只不过 Dijkstra 算法一般来说是有固定的起止位置的，然后计算这两点之间的最大或者最小</description>
    </item>
    
    <item>
      <title>最小生成树：Kruskal &amp; Prim 算法</title>
      <link>https://shishuochen.github.io/2023/sgdkfm6rd/</link>
      <pubDate>Thu, 22 Jun 2023 20:24:33 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/sgdkfm6rd/</guid>
      <description>写在前面 总结摘抄自labuladong 「树」和「图」的根本区别：树不会包含环，图可以包含环。一幅图可以有很多不同的生成树, 在所有可能的生成树</description>
    </item>
    
    <item>
      <title>并查集(Union-Find)算法及使用</title>
      <link>https://shishuochen.github.io/2023/eujqvjda2/</link>
      <pubDate>Thu, 22 Jun 2023 20:24:12 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/eujqvjda2/</guid>
      <description>写在前面 并查集（Union-Find）算法是一个专门针对「动态连通性」的算法。连通指的是一种等价关系：自反性、对称性、传递性。并查集算法提供</description>
    </item>
    
    <item>
      <title>二分图遍历染色</title>
      <link>https://shishuochen.github.io/2023/bi_kocjis/</link>
      <pubDate>Thu, 22 Jun 2023 20:12:07 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/bi_kocjis/</guid>
      <description>写在前面 从简单实用的角度来看，二分图结构在某些场景可以更高效地存储数据。不同于哈希表的一对一的映射；二分图可以做到一到多的映射，想象二分图中</description>
    </item>
    
    <item>
      <title>图的基本遍历、有向环检测、拓扑排序</title>
      <link>https://shishuochen.github.io/2023/z3ekdp0wl/</link>
      <pubDate>Mon, 19 Jun 2023 21:07:47 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/z3ekdp0wl/</guid>
      <description>写在前面 主要分为两种思路：利用visited数组与onpath数组的DFS遍历（逆后序排列）、利用队列的BFS遍历（需要用到节点的入度信息）</description>
    </item>
    
    <item>
      <title>扁平化嵌套列表迭代器</title>
      <link>https://shishuochen.github.io/2023/tw24pswjo/</link>
      <pubDate>Sat, 17 Jun 2023 22:53:15 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/tw24pswjo/</guid>
      <description>写在前面 看完题解，这道题其实应该不难，可能是因为看了题解所以不觉得难，哈哈哈；感觉主要是理解题意，特别要注意注释中的内部函数。 其实就相当于给</description>
    </item>
    
    <item>
      <title>快速排序详情及其应用</title>
      <link>https://shishuochen.github.io/2023/b5xhddsnk/</link>
      <pubDate>Sat, 17 Jun 2023 22:52:08 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/b5xhddsnk/</guid>
      <description>写在前面 对于一个无序数组，求第 $K$ 个最大元素，最容易想到的就是排序，然后选择相应位置的元素；其中有些排序算法是可以提前终止的，比如快速排序、冒</description>
    </item>
    
    <item>
      <title>二叉搜索树的构建</title>
      <link>https://shishuochen.github.io/2023/ik6kuzdd9/</link>
      <pubDate>Thu, 15 Jun 2023 20:21:47 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/ik6kuzdd9/</guid>
      <description>写在前面 二叉搜索树的题一定要利用二叉搜索树的特性：中序遍历特性、任意节点左子树都小于根节点，右子树大于根节点。 主要分为三个部分： 从最基本搜索</description>
    </item>
    
    <item>
      <title>归并排序及其应用</title>
      <link>https://shishuochen.github.io/2023/gh9fzukz5/</link>
      <pubDate>Tue, 13 Jun 2023 14:47:47 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/gh9fzukz5/</guid>
      <description>写在前面 看完labuladong的归并排序的应用后，准备稍稍总结下；来到题解区，翻了下三叶姐的题解（恐怖如斯，惊掉下巴~~） 原始数组：$nu</description>
    </item>
    
    <item>
      <title>二叉树的遍历：Morris遍历</title>
      <link>https://shishuochen.github.io/2023/okff76tzg/</link>
      <pubDate>Tue, 06 Jun 2023 18:15:28 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/okff76tzg/</guid>
      <description>写在前面 这种题回过头来再做一下，别有一番风味。之前没看过题解中的 Morris 遍历方法，只是简单的AC然后下一题，可能也不是很明所以然，借此记录一下 Morris 遍</description>
    </item>
    
    <item>
      <title>二分查找框架: x、f(x)、target</title>
      <link>https://shishuochen.github.io/2023/ff7ripv_q/</link>
      <pubDate>Tue, 30 May 2023 11:05:17 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/ff7ripv_q/</guid>
      <description>抽象出 $x、f(x)、target$ 框架 此题思路同 1011. 在 D 天内送达包裹的能力 - 力扣（LeetCode） 以及 875. 爱吃香蕉的珂珂 - 力扣（LeetCo</description>
    </item>
    
    <item>
      <title>528. 按权重随机选择</title>
      <link>https://shishuochen.github.io/2023/arinpegej/</link>
      <pubDate>Sun, 28 May 2023 22:42:17 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/arinpegej/</guid>
      <description>最朴素的想法 一开始，不会做，就想到了最简单的方法，那就是根据权重数组 $w$ 的索引值依次构建 $w[i]$ 个 $i$ 值，放入数组nums中，然后利用随机数生成一个值</description>
    </item>
    
    <item>
      <title>字符串匹配-KMP算法</title>
      <link>https://shishuochen.github.io/2023/k-flhnrms/</link>
      <pubDate>Sat, 27 May 2023 15:23:45 +0800</pubDate>
      
      <guid>https://shishuochen.github.io/2023/k-flhnrms/</guid>
      <description>KMP算法接触是从滑动窗口的使用开始的，因为涉及到模式（字符串）匹配，自己也是理解了好久才差不多弄懂，写在了LeetCode题解里，直接复制</description>
    </item>
    
    <item>
      <title>栈实现简单计算器</title>
      <link>https://shishuochen.github.io/2020/3aynm0ijd/</link>
      <pubDate>Sat, 11 Apr 2020 11:19:21 +0000</pubDate>
      
      <guid>https://shishuochen.github.io/2020/3aynm0ijd/</guid>
      <description>&amp;emsp;&amp;emsp;本文主要写如何用栈结构来实现简单的计算器 ，主要包括四则运算，并且在此基础上添加括号、乘方等，示例如下： $$-3.63\times (36.9+26.2)^{5}-5.3*(-2)\div 3.6^{2}.$$ 下面说说</description>
    </item>
    
    <item>
      <title>error: invalid operands of types &#39;double&#39; and &#39;int&#39; to binary &#39;operator%&#39;</title>
      <link>https://shishuochen.github.io/2020/msdlyc-zj/</link>
      <pubDate>Mon, 30 Mar 2020 14:12:18 +0000</pubDate>
      
      <guid>https://shishuochen.github.io/2020/msdlyc-zj/</guid>
      <description>在一次C++的练习中，我发现了这个问题，并在网上查找到了原因，特在此记录下来。 1️⃣ 基本 从字面意思来看就是说，类型int和double为二进</description>
    </item>
    
  </channel>
</rss>
